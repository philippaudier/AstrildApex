#version 410 core

layout(triangles, equal_spacing, ccw) in;

in vec3 tc_WorldPos[];
in vec3 tc_Normal[];
in vec2 tc_TexCoord[];

out vec3 v_WorldPos;
out vec3 v_Normal;
out vec2 v_TexCoord;

uniform sampler2D u_Heightmap; // heightmap bound by TerrainRenderer on unit 31
uniform float u_DispScale = 1.0; // how much to displace based on heightmap value
uniform mat4 u_Model;
uniform mat4 u_View;
uniform mat4 u_Projection;

// Hash function for pseudo-random noise
float hash(vec2 p)
{
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

float SampleHeightmapAtUV(vec2 uv)
{
    // Clamp UV to valid range
    uv = clamp(uv, vec2(0.0), vec2(1.0));

    // Direct texture lookup with hardware linear filtering
    float height = texture(u_Heightmap, uv).r;

    return clamp(height, 0.0, 1.0);
}

void main()
{
    // Interpolate attributes using barycentric coordinates (gl_TessCoord)
    vec3 p0 = tc_WorldPos[0];
    vec3 p1 = tc_WorldPos[1];
    vec3 p2 = tc_WorldPos[2];

    vec3 n0 = tc_Normal[0];
    vec3 n1 = tc_Normal[1];
    vec3 n2 = tc_Normal[2];

    vec2 uv0 = tc_TexCoord[0];
    vec2 uv1 = tc_TexCoord[1];
    vec2 uv2 = tc_TexCoord[2];

    vec3 bary = vec3(gl_TessCoord.x, gl_TessCoord.y, gl_TessCoord.z);
    vec3 pos = p0 * bary.x + p1 * bary.y + p2 * bary.z;
    vec3 normal = normalize(n0 * bary.x + n1 * bary.y + n2 * bary.z);
    vec2 uv = uv0 * bary.x + uv1 * bary.y + uv2 * bary.z;

    // Sample heightmap and displace along Y-axis (Unity style)
    float h = SampleHeightmapAtUV(uv);

    // Displace along world Y-axis instead of vertex normal for more predictable terrain
    vec3 displacement = vec3(0.0, h * u_DispScale, 0.0);
    pos += displacement;

    // Compute proper normal from heightmap gradient for smooth lighting
    vec2 texelSize = 1.0 / textureSize(u_Heightmap, 0);
    float hL = SampleHeightmapAtUV(uv + vec2(-texelSize.x, 0.0));
    float hR = SampleHeightmapAtUV(uv + vec2(texelSize.x, 0.0));
    float hD = SampleHeightmapAtUV(uv + vec2(0.0, -texelSize.y));
    float hU = SampleHeightmapAtUV(uv + vec2(0.0, texelSize.y));

    // Calculate gradient-based normal
    vec3 gradient;
    gradient.x = (hR - hL) * u_DispScale;
    gradient.y = 2.0; // Base strength
    gradient.z = (hU - hD) * u_DispScale;

    vec3 computedNormal = normalize(gradient);

    v_WorldPos = pos;
    v_Normal = computedNormal;
    v_TexCoord = uv;

    gl_Position = u_Projection * u_View * vec4(pos, 1.0);
}
