#version 410 core

layout(vertices = 3) out;

// Simple TCS that assigns outer tessellation levels based on camera distance.
// Expects per-vertex inputs: v_WorldPos, v_Normal, v_TexCoord passed from vertex shader.

in vec3 v_WorldPos[];
out vec3 tc_WorldPos[];

in vec3 v_Normal[];
out vec3 tc_Normal[];

in vec2 v_TexCoord[];
out vec2 tc_TexCoord[];

uniform vec3 u_ViewPos;
uniform float u_TessellationFactor = 1.0; // global multiplier

void main()
{
    // Pass through vertex data
    tc_WorldPos[gl_InvocationID] = v_WorldPos[gl_InvocationID];
    tc_Normal[gl_InvocationID] = v_Normal[gl_InvocationID];
    tc_TexCoord[gl_InvocationID] = v_TexCoord[gl_InvocationID];

    // Compute center of the patch to derive distance
    vec3 patchCenter = (v_WorldPos[0] + v_WorldPos[1] + v_WorldPos[2]) / 3.0;
    float dist = length(u_ViewPos - patchCenter);

    // Adaptive tessellation based on distance
    float maxDist = 500.0;
    float minDist = 10.0;
    float t = clamp((dist - minDist) / (maxDist - minDist), 0.0, 1.0);
    float rawLevel = mix(16.0, 4.0, t) * u_TessellationFactor;

    // Enforce minimum tess level of 4 to ensure solid triangles (not wireframe)
    float tessLevel = clamp(rawLevel, 4.0, 64.0);

    // Set outer and inner levels (triangles). All must be >= 4 for solid fill
    gl_TessLevelOuter[0] = tessLevel;
    gl_TessLevelOuter[1] = tessLevel;
    gl_TessLevelOuter[2] = tessLevel;
    gl_TessLevelInner[0] = tessLevel;
}
